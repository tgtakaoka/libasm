/*
 * Copyright 2020 Tadashi G. Takaoka
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "dis_formatter.h"

#include "str_buffer.h"

namespace libasm {
namespace driver {

DisFormatter::DisFormatter(Disassembler &disassembler, const char *input_name)
    : _disassembler(disassembler),
      _input_name(input_name),
      _formatter(*this),
      _insn(0),
      _uppercase(false) {
    _disassembler.setUpperHex(true);
    _disassembler.setUppercase(false);
    _formatter.setListRadix(_disassembler.listRadix());
}

void DisFormatter::setUpperHex(bool enable) {
    _formatter.setUpperHex(enable);
    _disassembler.setUpperHex(enable);
}

void DisFormatter::setUppercase(bool enable) {
    _uppercase = enable;
    _disassembler.setUppercase(enable);
}

void DisFormatter::reset() {
    _disassembler.resetError();
    /* There is at least one line even when generated byte is zero. */
    _nextContent = _nextLine = -1;
    _errorContent = _errorLine = false;
}

Error DisFormatter::disassemble(DisMemory &memory, uint32_t addr) {
    reset();
    _insn.reset(addr);
    const auto error = _disassembler.decode(memory, _insn, _operands, sizeof(_operands));
    _formatter.setListRadix(_disassembler.listRadix());
    return error;
}

Error DisFormatter::setCpu(const char *cpu) {
    reset();
    {
        _insn.reset(_insn.address());
        StrCaseBuffer out(_insn.nameBuffer(), _uppercase);
        out.text_P(PSTR("CPU")).over(_insn.nameBuffer());
    }
    {
        StrCaseBuffer out{_operands, sizeof(_operands), _uppercase};
        out.text(cpu);
    }
    return _disassembler.setCpu(cpu) ? UNSUPPORTED_CPU : OK;
}

Error DisFormatter::setOrigin(uint32_t origin) {
    reset();
    const auto err = config().checkAddr(origin);
    if (err)
        return err;
    {
        _insn.reset(origin);
        StrCaseBuffer out(_insn.nameBuffer(), _uppercase);
        out.text_P(PSTR("ORG")).over(_insn.nameBuffer());
    }
    {
        StrCaseBuffer out{_operands, sizeof(_operands), _uppercase};
        _disassembler.outAbsAddr(out, origin);
    }
    return OK;
}

bool DisFormatter::hasNextContent() const {
    return _nextContent < bytesSize();
}

static int max(int a, int b) {
    return a < b ? b : a;
}

const char *DisFormatter::getContent() {
    auto &out = _formatter.out();
    out.reset();
    if (isError()) {
        if (!_errorContent) {
            _errorContent = true;
            out.text_P(_disassembler.lineComment_P()).letter(' ').text(_input_name).text(": ");
            _disassembler.outAbsAddr(out, startAddress());
            out.text(": error: ").text_P(_disassembler.errorText_P());
            _nextContent = 0;
        } else {
            out.text_P(_disassembler.lineComment_P()).letter(' ');
            _formatter.formatAddress(startAddress() + _nextContent);
            _nextContent += _formatter.formatBytes(_nextContent);
        }
    } else {
        out.text("      ");
        const auto pos = out.len();
        out.text(_insn.name());
        if (*_operands) {
            const auto nameWidth = max(config().nameMax(), min_nameWidth) + 1;
            _formatter.formatTab(pos + nameWidth);
            out.text(_operands);
        }
        _nextContent = bytesSize();
    }
    return out.str();
}

bool DisFormatter::hasNextLine() const {
    return _nextLine < bytesSize();
}

const char *DisFormatter::getLine() {
    auto &out = _formatter.out();
    out.reset();
    if (isError() && !_errorLine) {
        _errorLine = true;
        out.text(_input_name).text(": ");
        _disassembler.outAbsAddr(out, startAddress());
        out.text(": error: ").text_P(_disassembler.errorText_P());
        _nextLine = 0;
    } else {
        if (_nextLine < 0)
            _nextLine = 0;
        _formatter.formatAddress(startAddress() + _nextLine);
        auto pos = out.len();
        const auto formatted = _formatter.formatBytes(_nextLine);
        if (_nextLine == 0 && *_insn.name()) {
            _formatter.formatTab(pos + _formatter.bytesColumnWidth() + 1);
            out.text("        ");
            pos = out.len();
            out.text(_insn.name());
            if (*_operands) {
                const auto nameWidth = max(config().nameMax(), min_nameWidth) + 1;
                _formatter.formatTab(pos + nameWidth);
                out.text(_operands);
            }
        }
        _nextLine += formatted;
    }
    return out.str();
}

}  // namespace driver
}  // namespace libasm

// Local Variables:
// mode: c++
// c-basic-offset: 4
// tab-width: 4
// End:
// vim: set ft=cpp et ts=4 sw=4:
