image:https://img.shields.io/github/v/release/tgtakaoka/libasm.svg?maxAge=3600[https://github.com/tgtakaoka/libasm/releases]
image:https://img.shields.io/badge/License-Apache%202.0-blue.svg[https://github.com/tgtakaoka/libasm/blob/main/LICENSE.md]
image:https://github.com/tgtakaoka/libasm/actions/workflows/ccpp.yml/badge.svg[link="https://github.com/tgtakaoka/libasm/actions/workflows/ccpp.yml"]
image:https://github.com/tgtakaoka/libasm/actions/workflows/arduino-ci.yml/badge.svg[https://github.com/tgtakaoka/libasm/actions/workflows/arduino-ci.yml]
image:https://github.com/tgtakaoka/libasm/actions/workflows/platformio-ci.yml/badge.svg[https://github.com/tgtakaoka/libasm/actions/workflows/platformio-ci.yml]

= libasm: cross assemble/disassemble library =

The libasm allows assembling and disassembling supported retro CPUs on
a small environment (less than 9kB-17kB Flash and 350B RAM on AVR
Arduino).

== Assembler library interface ==

Assembling MC68HC11 instruction in string to binary can be done in a
minutes. You can also add symbols table lookup via
https://github.com/tgtakaoka/libasm/blob/main/src/array_memory.h[`SymbolTable`]
interface.

    #include <asm_mc6800.h>
    libasm::mc6800::AsmMc6800 asm6800;
    asm6800.setCpu("68HC11");

    const char *text = "SUBD $90";
    libasm::Insn insn(0x1000);

    asm6800.encode(text, insn);
    assert(insn.address()  == 0x1000);
    assert(insn.length()   == 2);    // direct addressing
    assert(insn.bytes()[0] == 0x93); // SUBD
    assert(insn.bytes()[1] == 0x90); // $90

== Disassembler library interface ==

To disassemble MC68000 binaries, you need to wrap memory by
https://github.com/tgtakaoka/libasm/blob/main/src/array_memory.h[`ArrayMemory`]
or implements your own
https://github.com/tgtakaoka/libasm/blob/main/src/dis_memory.h[`DisMemory`]
interface to feed binaries. You can also add symbol table lookup via
https://github.com/tgtakaoka/libasm/blob/main/src/array_memory.h[`SymbolTable`]
interface.

    #include <dis_mc68000.h>
    libasm::mc68000::DisMc68000 dis68k;
    dis68k.setRelativeTarget(true);

    const uint16_t words[] = {0047372, 0x1232};
    libasm::ArrayMemory memory(0x100, words, sizeof(words));
    libasm::Insn insn(0x100);
    char opr[80];

    dis68k.decode(memory, insn, opr, sizeof(opr));
    assert(insn.address() == 0x100);
    assert(std::string(insn.name()) == "jmp");
    assert(std::string(opr) == "(*+$1234,pc)");

== Assembler command line interface ==

On POSIX environment, assembler command line interface is provided.
It can generate Intel HEX or Motorola S-Record output.

    libasm assembler (version 1.6.19)
    usage: asm [-o <output>] [-l <list>] <input>
      -C <CPU>    : target CPU
                    MC6800, MC6801, HD6301, MC68HC11, MC6805, MC146805, MC68HC05
                    MC6809, HD6309, MOS6502, R65C02, G65SC02, W65C02S, W65C816S
                    i8039, i8048, i80C39, i80C48, MSM80C39, MSM80C48, i8051
                    i8080, i8085, Z80, Z8, Z86C, Z88, TLCS90, INS8060, INS8070
                    CDP1802, CDP1804, CDP1804A, TMS32010, TMS32015, i8086
                    MC68000, TMS9900, TMS9995, TMS99105, Z8001, Z8002, NS32032
                    MN1610, MN1613, MN1613A
      -o <output> : output file
      -l <list>   : list file
      -S[<bytes>] : output Motorola S-Record format
      -H[<bytes>] : output Intel HEX format
                  : optional <bytes> specifies data record length (max 32)
      -u          : use uppercase letter for listing
      -n          : output line number to list file
      -v          : print progress verbosely

== Disassembler command line interface ==

On POSIX environment, disassembler command line interface is provided.
It can read Intel HEX or Motorola S-Record input.

    libasm disassembler (version 1.6.19)
    usage: dis -C <CPU> [-o <output>] [-l <list>] <input>
      -C <CPU>    : target CPU
                    MC6800, MC6801, HD6301, MC68HC11, MC6805, MC146805, MC68HC05
                    MC6809, HD6309, MOS6502, R65C02, G65SC02, W65C02S, W65C816S
                    i8039, i8048, i80C39, i80C48, MSM80C39, MSM80C48, i8051
                    i8080, i8085, Z80, Z8, Z86C, Z88, TLCS90, INS8060, INS8070
                    CDP1802, CDP1804, CDP1804A, TMS32010, TMS32015, i8086
                    MC68000, TMS9900, TMS9995, TMS99105, Z8001, Z8002, NS32032
                    MN1610, MN1613, MN1613A
      -o <output> : output file
      -l <list>   : list file
      <input>     : file can be Motorola S-Record or Intel HEX format
      -A start[,end]
                  : disassemble start address and optional end address
      -r          : use program counter relative notation
      -u          : use uppercase letter for output
      -v          : print progress verbosely

== Supported host environment ==

* Arduino (avr, megaavr, samd, teensy)
* PlatformIO (atmelavr, atmelmegaavr, atmelsam, teensy)
* Linux, macOS (C++14)

NOTE: More information about this library can be found at
https://github.com/tgtakaoka/libasm[GitHub]
